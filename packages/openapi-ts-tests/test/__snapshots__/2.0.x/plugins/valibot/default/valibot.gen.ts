// This file is auto-generated by @hey-api/openapi-ts

import * as v from 'valibot';

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const vCommentWithBreaks = v.pipe(v.number(), v.integer());

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const vCommentWithBackticks = v.pipe(v.number(), v.integer());

/**
 * Testing backticks and quotes in string: `backticks`, 'quotes', "double quotes" and ```multiple backticks``` should work
 */
export const vCommentWithBackticksAndQuotes = v.pipe(v.number(), v.integer());

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const vCommentWithSlashes = v.pipe(v.number(), v.integer());

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const vCommentWithExpressionPlaceholders = v.pipe(v.number(), v.integer());

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const vCommentWithQuotes = v.pipe(v.number(), v.integer());

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const vCommentWithReservedCharacters = v.pipe(v.number(), v.integer());

/**
 * This is a simple number
 */
export const vSimpleInteger = v.pipe(v.number(), v.integer());

/**
 * This is a simple boolean
 */
export const vSimpleBoolean = v.boolean();

/**
 * This is a simple string
 */
export const vSimpleString = v.string();

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export const vNonAsciiStringæøåÆøÅöôêÊ字符串 = v.string();

/**
 * This is a simple file
 */
export const vSimpleFile = v.string();

/**
 * This is a model with one string property
 */
export const vModelWithString = v.object({
    prop: v.optional(v.string())
});

export const vSimpleReference = vModelWithString;

/**
 * This is a simple string
 */
export const vSimpleStringWithPattern = v.pipe(v.string(), v.maxLength(64), v.regex(/^[a-zA-Z0-9_]*$/));

/**
 * This is a simple enum with strings
 */
export const vEnumWithStrings = v.picklist([
    'Success',
    'Warning',
    'Error',
    "'Single Quote'",
    '"Double Quotes"',
    'Non-ascii: øæåôöØÆÅÔÖ字符串'
]);

/**
 * This is a simple enum with numbers
 */
export const vEnumWithNumbers = v.unknown();

/**
 * Success=1,Warning=2,Error=3
 */
export const vEnumFromDescription = v.number();

/**
 * This is a simple enum with numbers
 */
export const vEnumWithExtensions = v.unknown();

/**
 * This is a simple array with numbers
 */
export const vArrayWithNumbers = v.array(v.pipe(v.number(), v.integer()));

/**
 * This is a simple array with booleans
 */
export const vArrayWithBooleans = v.array(v.boolean());

/**
 * This is a simple array with strings
 */
export const vArrayWithStrings = v.array(v.string());

/**
 * This is a simple array with references
 */
export const vArrayWithReferences = v.array(vModelWithString);

/**
 * This is a simple array containing an array
 */
export const vArrayWithArray = v.array(v.array(vModelWithString));

/**
 * This is a simple array with properties
 */
export const vArrayWithProperties = v.array(v.object({
    foo: v.optional(v.string()),
    bar: v.optional(v.string())
}));

/**
 * This is a string dictionary
 */
export const vDictionaryWithString = v.object({});

/**
 * This is a string reference
 */
export const vDictionaryWithReference = v.object({});

/**
 * This is a complex dictionary
 */
export const vDictionaryWithArray = v.object({});

/**
 * This is a string dictionary
 */
export const vDictionaryWithDictionary = v.object({});

/**
 * This is a complex dictionary
 */
export const vDictionaryWithProperties = v.object({});

/**
 * This is a type-only model that defines Date as a string
 */
export const vDate = v.string();

/**
 * This is a model with one number property
 */
export const vModelWithInteger = v.object({
    prop: v.optional(v.pipe(v.number(), v.integer()))
});

/**
 * This is a model with one boolean property
 */
export const vModelWithBoolean = v.object({
    prop: v.optional(v.boolean())
});

/**
 * This is a model with one string property
 */
export const vModelWithStringError = v.object({
    prop: v.optional(v.string())
});

/**
 * This is a model with one string property
 */
export const vModelWithNullableString = v.object({
    nullableProp: v.optional(v.union([
        v.string(),
        v.null()
    ])),
    nullableRequiredProp: v.union([
        v.string(),
        v.null()
    ])
});

/**
 * This is a model with one enum
 */
export const vModelWithEnum = v.object({
    test: v.optional(v.picklist([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ])),
    statusCode: v.optional(v.picklist([
        '100',
        '200 FOO',
        '300 FOO_BAR',
        '400 foo-bar',
        '500 foo.bar',
        '600 foo&bar'
    ])),
    bool: v.optional(v.unknown())
});

/**
 * This is a model with one enum
 */
export const vModelWithEnumFromDescription = v.object({
    test: v.optional(v.pipe(v.number(), v.integer()))
});

/**
 * This is a model with nested enums
 */
export const vModelWithNestedEnums = v.object({
    dictionaryWithEnum: v.optional(v.object({})),
    dictionaryWithEnumFromDescription: v.optional(v.object({})),
    arrayWithEnum: v.optional(v.array(v.picklist([
        'Success',
        'Warning',
        'Error'
    ]))),
    arrayWithDescription: v.optional(v.array(v.pipe(v.number(), v.integer())))
});

/**
 * This is a model with one nested property
 */
export const vModelWithProperties = v.object({
    required: v.string(),
    requiredAndReadOnly: v.pipe(v.string(), v.readonly()),
    string: v.optional(v.string()),
    number: v.optional(v.number()),
    boolean: v.optional(v.boolean()),
    reference: v.optional(vModelWithString),
    'property with space': v.optional(v.string()),
    default: v.optional(v.string()),
    try: v.optional(v.string()),
    '@namespace.string': v.optional(v.pipe(v.string(), v.readonly())),
    '@namespace.integer': v.optional(v.pipe(v.pipe(v.number(), v.integer()), v.readonly()))
});

/**
 * This is a model with one property containing a reference
 */
export const vModelWithReference = v.object({
    prop: v.optional(vModelWithProperties)
});

/**
 * This is a model with one property containing an array
 */
export const vModelWithArray = v.object({
    prop: v.optional(v.array(vModelWithString)),
    propWithFile: v.optional(v.array(v.string())),
    propWithNumber: v.optional(v.array(v.number()))
});

/**
 * This is a model with one property containing a dictionary
 */
export const vModelWithDictionary = v.object({
    prop: v.optional(v.object({}))
});

/**
 * This is a model with one property containing a circular reference
 */
export const vModelWithCircularReference: v.GenericSchema = v.object({
    prop: v.optional(v.lazy(() => {
        return vModelWithCircularReference;
    }))
});

/**
 * This is a model with one nested property
 */
export const vModelWithNestedProperties = v.object({
    first: v.pipe(v.object({
        second: v.pipe(v.object({
            third: v.pipe(v.string(), v.readonly())
        }), v.readonly())
    }), v.readonly())
});

/**
 * This is a model with duplicated properties
 */
export const vModelWithDuplicateProperties = v.object({
    prop: v.optional(vModelWithString)
});

/**
 * This is a model with ordered properties
 */
export const vModelWithOrderedProperties = v.object({
    zebra: v.optional(v.string()),
    apple: v.optional(v.string()),
    hawaii: v.optional(v.string())
});

/**
 * This is a model with duplicated imports
 */
export const vModelWithDuplicateImports = v.object({
    propA: v.optional(vModelWithString),
    propB: v.optional(vModelWithString),
    propC: v.optional(vModelWithString)
});

/**
 * This is a model that extends another model
 */
export const vModelThatExtends = v.intersect([
    vModelWithString,
    v.object({
        propExtendsA: v.optional(v.string()),
        propExtendsB: v.optional(vModelWithString)
    })
]);

/**
 * This is a model that extends another model
 */
export const vModelThatExtendsExtends = v.intersect([
    vModelWithString,
    vModelThatExtends,
    v.object({
        propExtendsC: v.optional(v.string()),
        propExtendsD: v.optional(vModelWithString)
    })
]);

export const vDefault = v.object({
    name: v.optional(v.string())
});

/**
 * This is a model that contains a some patterns
 */
export const vModelWithPattern = v.object({
    key: v.pipe(v.string(), v.maxLength(64), v.regex(/^[a-zA-Z0-9_]*$/)),
    name: v.pipe(v.string(), v.maxLength(255)),
    enabled: v.optional(v.pipe(v.boolean(), v.readonly())),
    modified: v.optional(v.pipe(v.pipe(v.string(), v.isoDateTime()), v.readonly())),
    id: v.optional(v.pipe(v.string(), v.regex(/^\d{2}-\d{3}-\d{4}$/))),
    text: v.optional(v.pipe(v.string(), v.regex(/^\w+$/))),
    patternWithSingleQuotes: v.optional(v.pipe(v.string(), v.regex(/^[a-zA-Z0-9']*$/))),
    patternWithNewline: v.optional(v.pipe(v.string(), v.regex(/aaa\nbbb/))),
    patternWithBacktick: v.optional(v.pipe(v.string(), v.regex(/aaa`bbb/)))
});

export const vParameterActivityParams = v.object({
    description: v.optional(v.string()),
    graduate_id: v.optional(v.pipe(v.number(), v.integer())),
    organization_id: v.optional(v.pipe(v.number(), v.integer())),
    parent_activity: v.optional(v.pipe(v.number(), v.integer())),
    post_id: v.optional(v.pipe(v.number(), v.integer()))
});

export const vResponsePostActivityResponse = v.object({
    description: v.optional(v.string()),
    graduate_id: v.optional(v.pipe(v.number(), v.integer())),
    organization_id: v.optional(v.pipe(v.number(), v.integer())),
    parent_activity_id: v.optional(v.pipe(v.number(), v.integer())),
    post_id: v.optional(v.pipe(v.number(), v.integer()))
});

export const vFailureFailure = v.object({
    error: v.optional(v.string()),
    message: v.optional(v.string()),
    reference_code: v.optional(v.string())
});

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const vCallWithDescriptionsParameterParameterWithBreaks = v.string();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const vCallWithDescriptionsParameterParameterWithBackticks = v.string();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const vCallWithDescriptionsParameterParameterWithSlashes = v.string();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const vCallWithDescriptionsParameterParameterWithExpressionPlaceholders = v.string();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const vCallWithDescriptionsParameterParameterWithQuotes = v.string();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const vCallWithDescriptionsParameterParameterWithReservedCharacters = v.string();

/**
 * This is the parameter that goes into the header
 */
export const vCallWithParametersParameterParameterHeader = v.string();

/**
 * This is the parameter that goes into the path
 */
export const vCallWithParametersParameterParameterPath = v.string();

/**
 * api-version should be required in standalone clients
 */
export const vCallWithParametersParameterApiVersion = v.string();

/**
 * This is the parameter that goes into the query params
 */
export const vCallWithParametersParameterParameterQuery = v.string();

/**
 * This is the parameter that goes into the request header
 */
export const vCallWithWeirdParameterNamesParameterParameterHeader = v.string();

/**
 * This is the parameter that goes into the path
 */
export const vCallWithWeirdParameterNamesParameterParameterPath1 = v.string();

/**
 * This is the parameter that goes into the path
 */
export const vCallWithWeirdParameterNamesParameterParameterPath2 = v.string();

/**
 * This is the parameter that goes into the path
 */
export const vCallWithWeirdParameterNamesParameterParameterPath3 = v.string();

/**
 * api-version should be required in standalone clients
 */
export const vCallWithWeirdParameterNamesParameterApiVersion = v.string();

/**
 * This is the parameter with a reserved keyword
 */
export const vCallWithWeirdParameterNamesParameterDefault = v.string();

/**
 * This is the parameter that goes into the request query params
 */
export const vCallWithWeirdParameterNamesParameterParameterQuery = v.string();

/**
 * This is a simple string with default value
 */
export const vCallWithDefaultParametersParameterParameterString = v.optional(v.string(), 'Hello World!');

/**
 * This is a simple number with default value
 */
export const vCallWithDefaultParametersParameterParameterNumber = v.optional(v.number(), 123);

/**
 * This is a simple boolean with default value
 */
export const vCallWithDefaultParametersParameterParameterBoolean = v.optional(v.boolean(), true);

/**
 * This is a simple enum with default value
 */
export const vCallWithDefaultParametersParameterParameterEnum = v.picklist([
    'Success',
    'Warning',
    'Error'
]);

/**
 * This is a model with one string property
 */
export const vCallWithDefaultParametersParameterParameterModel = v.optional(v.object({
    prop: v.optional(v.string())
}), {
    prop: 'Hello World!'
});

/**
 * This is a simple string that is optional with default value
 */
export const vCallWithDefaultOptionalParametersParameterParameterString = v.optional(v.string(), 'Hello World!');

/**
 * This is a simple number that is optional with default value
 */
export const vCallWithDefaultOptionalParametersParameterParameterNumber = v.optional(v.number(), 123);

/**
 * This is a simple boolean that is optional with default value
 */
export const vCallWithDefaultOptionalParametersParameterParameterBoolean = v.optional(v.boolean(), true);

/**
 * This is a simple enum that is optional with default value
 */
export const vCallWithDefaultOptionalParametersParameterParameterEnum = v.picklist([
    'Success',
    'Warning',
    'Error'
]);

/**
 * This is a optional string with default
 */
export const vCallToTestOrderOfParamsParameterParameterOptionalStringWithDefault = v.optional(v.string(), 'Hello World!');

/**
 * This is a optional string with empty default
 */
export const vCallToTestOrderOfParamsParameterParameterOptionalStringWithEmptyDefault = v.optional(v.string(), '');

/**
 * This is a optional string with no default
 */
export const vCallToTestOrderOfParamsParameterParameterOptionalStringWithNoDefault = v.string();

/**
 * This is a string with default
 */
export const vCallToTestOrderOfParamsParameterParameterStringWithDefault = v.optional(v.string(), 'Hello World!');

/**
 * This is a string with empty default
 */
export const vCallToTestOrderOfParamsParameterParameterStringWithEmptyDefault = v.optional(v.string(), '');

/**
 * This is a string with no default
 */
export const vCallToTestOrderOfParamsParameterParameterStringWithNoDefault = v.string();

/**
 * This is a string that can be null with no default
 */
export const vCallToTestOrderOfParamsParameterParameterStringNullableWithNoDefault = v.union([
    v.string(),
    v.null()
]);

/**
 * This is a string that can be null with default
 */
export const vCallToTestOrderOfParamsParameterParameterStringNullableWithDefault = v.optional(v.union([
    v.string(),
    v.null()
]), null);

export const vCallWithResponseAndNoContentResponseResponse = v.union([
    v.number(),
    v.unknown()
]);

/**
 * Message for default response
 */
export const vCallWithResponseResponse = vModelWithString;

/**
 * Message for 201 response
 */
export const vCallWithDuplicateResponsesResponse = vModelWithString;

export const vCallWithResponsesResponse = v.union([
    v.object({
        '@namespace.string': v.optional(v.pipe(v.string(), v.readonly())),
        '@namespace.integer': v.optional(v.pipe(v.pipe(v.number(), v.integer()), v.readonly())),
        value: v.optional(v.pipe(v.array(vModelWithString), v.readonly()))
    }),
    vModelThatExtends,
    vModelThatExtendsExtends
]);

/**
 * This is an array parameter that is sent as csv format (comma-separated values)
 */
export const vCollectionFormatParameterParameterArrayCsv = v.array(v.string());

/**
 * This is an array parameter that is sent as ssv format (space-separated values)
 */
export const vCollectionFormatParameterParameterArraySsv = v.array(v.string());

/**
 * This is an array parameter that is sent as tsv format (tab-separated values)
 */
export const vCollectionFormatParameterParameterArrayTsv = v.array(v.string());

/**
 * This is an array parameter that is sent as pipes format (pipe-separated values)
 */
export const vCollectionFormatParameterParameterArrayPipes = v.array(v.string());

/**
 * This is an array parameter that is sent as multi format (multiple parameter instances)
 */
export const vCollectionFormatParameterParameterArrayMulti = v.array(v.string());

/**
 * This is a number parameter
 */
export const vTypesParameterId = v.pipe(v.number(), v.integer());

/**
 * This is a number parameter
 */
export const vTypesParameterParameterNumber = v.optional(v.number(), 123);

/**
 * This is a string parameter
 */
export const vTypesParameterParameterString = v.optional(v.string(), 'default');

/**
 * This is a boolean parameter
 */
export const vTypesParameterParameterBoolean = v.optional(v.boolean(), true);

/**
 * This is an array parameter
 */
export const vTypesParameterParameterArray = v.array(v.string());

/**
 * This is a dictionary parameter
 */
export const vTypesParameterParameterDictionary = v.object({});

/**
 * This is an enum parameter
 */
export const vTypesParameterParameterEnum = v.picklist([
    'Success',
    'Warning',
    'Error'
]);

export const vTypesResponse = v.union([
    v.number(),
    v.string(),
    v.boolean(),
    v.object({})
]);

/**
 * Parameter containing object
 */
export const vComplexTypesParameterParameterObject = v.object({
    first: v.optional(v.object({
        second: v.optional(v.object({
            third: v.optional(v.string())
        }))
    }))
});

/**
 * This is a model with one string property
 */
export const vComplexTypesParameterParameterReference = v.object({
    prop: v.optional(v.string())
});

/**
 * Successful response
 */
export const vComplexTypesResponse = v.array(vModelWithString);

/**
 * Status code to return
 */
export const vTestErrorCodeParameterStatus = v.string();

/**
 * Dummy input param
 */
export const vNonAsciiæøåÆøÅöôêÊ字符串ParameterNonAsciiParamæøåÆøÅöôêÊ = v.pipe(v.number(), v.integer());

/**
 * Successful response
 */
export const vNonAsciiæøåÆøÅöôêÊ字符串Response = vNonAsciiStringæøåÆøÅöôêÊ字符串;

/**
 * Body should not be unknown
 */
export const vPostApiVbyApiVersionBodyData = vParameterActivityParams;

/**
 * OK
 */
export const vPostApiVbyApiVersionBodyResponse = vResponsePostActivityResponse;