// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Model with number-only name
 */
export const z400 = z.string();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCamelCaseCommentWithBreaks = z.number().int();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCommentWithBreaks = z.number().int();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const zCommentWithBackticks = z.number().int();

/**
 * Testing backticks and quotes in string: `backticks`, 'quotes', "double quotes" and ```multiple backticks``` should work
 */
export const zCommentWithBackticksAndQuotes = z.number().int();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const zCommentWithSlashes = z.number().int();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const zCommentWithExpressionPlaceholders = z.number().int();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const zCommentWithQuotes = z.number().int();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const zCommentWithReservedCharacters = z.number().int();

/**
 * This is a simple number
 */
export const zSimpleInteger = z.number().int();

/**
 * This is a simple boolean
 */
export const zSimpleBoolean = z.boolean();

/**
 * This is a simple string
 */
export const zSimpleString = z.string();

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export const zNonAsciiStringæøåÆøÅöôêÊ字符串 = z.string();

/**
 * This is a simple file
 */
export const zSimpleFile = z.string();

/**
 * This is a model with one string property
 */
export const zModelWithString = z.object({
    prop: z.string().optional()
});

/**
 * This is a simple reference
 */
export const zSimpleReference = zModelWithString;

/**
 * This is a simple string
 */
export const zSimpleStringWithPattern = z.union([
    z.string().max(64).regex(/^[a-zA-Z0-9_]*$/),
    z.null()
]);

/**
 * This is a simple enum with strings
 */
export const zEnumWithStrings = z.enum([
    'Success',
    'Warning',
    'Error',
    "'Single Quote'",
    '"Double Quotes"',
    'Non-ascii: øæåôöØÆÅÔÖ字符串'
]);

export const zEnumWithReplacedCharacters = z.enum([
    "'Single Quote'",
    '"Double Quotes"',
    'øæåôöØÆÅÔÖ字符串',
    ''
]);

/**
 * This is a simple enum with numbers
 */
export const zEnumWithNumbers = z.unknown();

/**
 * Success=1,Warning=2,Error=3
 */
export const zEnumFromDescription = z.number();

/**
 * This is a simple enum with numbers
 */
export const zEnumWithExtensions = z.unknown();

export const zEnumWithXEnumNames = z.unknown();

/**
 * This is a simple array with numbers
 */
export const zArrayWithNumbers = z.array(z.number().int());

/**
 * This is a simple array with booleans
 */
export const zArrayWithBooleans = z.array(z.boolean());

/**
 * This is a simple array with strings
 */
export const zArrayWithStrings = z.array(z.string()).default(['test']);

/**
 * This is a simple array with references
 */
export const zArrayWithReferences = z.array(zModelWithString);

/**
 * This is a simple array containing an array
 */
export const zArrayWithArray = z.array(z.array(zModelWithString));

/**
 * This is a simple array with properties
 */
export const zArrayWithProperties = z.array(z.object({
    '16x16': zCamelCaseCommentWithBreaks.optional(),
    bar: z.string().optional()
}));

/**
 * This is a simple array with any of properties
 */
export const zArrayWithAnyOfProperties = z.array(z.unknown());

export const zAnyOfAnyAndNull = z.object({
    data: z.unknown().optional()
});

/**
 * This is a simple array with any of properties
 */
export const zAnyOfArrays = z.object({
    results: z.array(z.unknown()).optional()
});

/**
 * This is a string dictionary
 */
export const zDictionaryWithString = z.object({});

export const zDictionaryWithPropertiesAndAdditionalProperties = z.object({
    foo: z.number().optional(),
    bar: z.boolean().optional()
});

/**
 * This is a string reference
 */
export const zDictionaryWithReference = z.object({});

/**
 * This is a complex dictionary
 */
export const zDictionaryWithArray = z.object({});

/**
 * This is a string dictionary
 */
export const zDictionaryWithDictionary = z.object({});

/**
 * This is a complex dictionary
 */
export const zDictionaryWithProperties = z.object({});

/**
 * This is a model with one number property
 */
export const zModelWithInteger = z.object({
    prop: z.number().int().optional()
});

/**
 * This is a model with one boolean property
 */
export const zModelWithBoolean = z.object({
    prop: z.boolean().optional()
});

/**
 * This is a model with one string property
 */
export const zModelWithStringError = z.object({
    prop: z.string().optional()
});

/**
 * `Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)
 */
export const zModelFromZendesk = z.string();

/**
 * This is a model with one string property
 */
export const zModelWithNullableString = z.object({
    nullableProp1: z.union([
        z.string(),
        z.null()
    ]).optional(),
    nullableRequiredProp1: z.union([
        z.string(),
        z.null()
    ]),
    nullableProp2: z.union([
        z.string(),
        z.null()
    ]).optional(),
    nullableRequiredProp2: z.union([
        z.string(),
        z.null()
    ]),
    'foo_bar-enum': z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ]).optional()
});

/**
 * This is a model with one enum
 */
export const zModelWithEnum = z.object({
    'foo_bar-enum': z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ]).optional(),
    statusCode: z.enum([
        '100',
        '200 FOO',
        '300 FOO_BAR',
        '400 foo-bar',
        '500 foo.bar',
        '600 foo&bar'
    ]).optional(),
    bool: z.unknown().optional()
});

/**
 * This is a model with one enum with escaped name
 */
export const zModelWithEnumWithHyphen = z.object({
    'foo-bar-baz-qux': z.enum([
        '3.0'
    ]).optional()
});

/**
 * This is a model with one enum
 */
export const zModelWithEnumFromDescription = z.object({
    test: z.number().int().optional()
});

/**
 * This is a model with nested enums
 */
export const zModelWithNestedEnums = z.object({
    dictionaryWithEnum: z.object({}).optional(),
    dictionaryWithEnumFromDescription: z.object({}).optional(),
    arrayWithEnum: z.array(z.enum([
        'Success',
        'Warning',
        'Error'
    ])).optional(),
    arrayWithDescription: z.array(z.number().int()).optional(),
    'foo_bar-enum': z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ]).optional()
});

/**
 * This is a model with one nested property
 */
export const zModelWithProperties = z.object({
    required: z.string(),
    requiredAndReadOnly: z.string().readonly(),
    requiredAndNullable: z.union([
        z.string(),
        z.null()
    ]),
    string: z.string().optional(),
    number: z.number().optional(),
    boolean: z.boolean().optional(),
    reference: zModelWithString.optional(),
    'property with space': z.string().optional(),
    default: z.string().optional(),
    try: z.string().optional(),
    '@namespace.string': z.string().readonly().optional(),
    '@namespace.integer': z.number().int().readonly().optional()
});

/**
 * This is a model with one property containing a reference
 */
export const zModelWithReference = z.object({
    prop: zModelWithProperties.optional()
});

export const zModelWithReadOnlyAndWriteOnly = z.object({
    foo: z.string(),
    bar: z.string().readonly(),
    baz: z.string()
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArrayReadOnlyAndWriteOnly = z.object({
    prop: z.array(zModelWithReadOnlyAndWriteOnly).optional(),
    propWithFile: z.array(z.string()).optional(),
    propWithNumber: z.array(z.number()).optional()
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArray = z.object({
    prop: z.array(zModelWithString).optional(),
    propWithFile: z.array(z.string()).optional(),
    propWithNumber: z.array(z.number()).optional()
});

/**
 * This is a model with one property containing a dictionary
 */
export const zModelWithDictionary = z.object({
    prop: z.object({}).optional()
});

/**
 * This is a deprecated model with a deprecated property
 * @deprecated
 */
export const zDeprecatedModel = z.object({
    prop: z.string().optional()
});

/**
 * This is a model with one property containing a circular reference
 */
export const zModelWithCircularReference: z.AnyZodObject = z.object({
    prop: z.lazy(() => {
        return zModelWithCircularReference;
    }).optional()
});

/**
 * This is a model with one property with a 'one of' relationship
 */
export const zCompositionWithOneOf = z.object({
    propA: z.union([
        zModelWithString,
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary
    ]).optional()
});

/**
 * This is a model with one property with a 'one of' relationship where the options are not $ref
 */
export const zCompositionWithOneOfAnonymous = z.object({
    propA: z.union([
        z.object({
            propA: z.string().optional()
        }),
        z.string(),
        z.number().int()
    ]).optional()
});

/**
 * Circle
 */
export const zModelCircle = z.object({
    kind: z.string(),
    radius: z.number().optional()
});

/**
 * Square
 */
export const zModelSquare = z.object({
    kind: z.string(),
    sideLength: z.number().optional()
});

/**
 * This is a model with one property with a 'one of' relationship where the options are not $ref
 */
export const zCompositionWithOneOfDiscriminator = z.union([
    z.object({
        kind: z.literal('circle')
    }).and(zModelCircle),
    z.object({
        kind: z.literal('square')
    }).and(zModelSquare)
]);

/**
 * This is a model with one property with a 'any of' relationship
 */
export const zCompositionWithAnyOf = z.object({
    propA: z.union([
        zModelWithString,
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary
    ]).optional()
});

/**
 * This is a model with one property with a 'any of' relationship where the options are not $ref
 */
export const zCompositionWithAnyOfAnonymous = z.object({
    propA: z.union([
        z.object({
            propA: z.string().optional()
        }),
        z.string(),
        z.number().int()
    ]).optional()
});

/**
 * This is a model with nested 'any of' property with a type null
 */
export const zCompositionWithNestedAnyAndTypeNull = z.object({
    propA: z.union([
        z.array(z.union([
            zModelWithDictionary,
            z.null()
        ])),
        z.array(z.union([
            zModelWithArray,
            z.null()
        ]))
    ]).optional()
});

export const z3eNum1Период = z.enum([
    'Bird',
    'Dog'
]);

export const zConstValue = z.enum([
    'ConstValue'
]);

/**
 * This is a model with one property with a 'any of' relationship where the options are not $ref
 */
export const zCompositionWithNestedAnyOfAndNull = z.object({
    propA: z.union([
        z.array(z.unknown()),
        z.null()
    ]).optional()
});

/**
 * This is a model with one property with a 'one of' relationship
 */
export const zCompositionWithOneOfAndNullable = z.object({
    propA: z.union([
        z.object({
            boolean: z.boolean().optional()
        }),
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary,
        z.null()
    ]).optional()
});

/**
 * This is a model that contains a simple dictionary within composition
 */
export const zCompositionWithOneOfAndSimpleDictionary = z.object({
    propA: z.union([
        z.boolean(),
        z.object({})
    ]).optional()
});

/**
 * This is a model that contains a dictionary of simple arrays within composition
 */
export const zCompositionWithOneOfAndSimpleArrayDictionary = z.object({
    propA: z.union([
        z.boolean(),
        z.object({})
    ]).optional()
});

/**
 * This is a model that contains a dictionary of complex arrays (composited) within composition
 */
export const zCompositionWithOneOfAndComplexArrayDictionary = z.object({
    propA: z.union([
        z.boolean(),
        z.object({})
    ]).optional()
});

/**
 * This is a model with one property with a 'all of' relationship
 */
export const zCompositionWithAllOfAndNullable = z.object({
    propA: z.union([
        z.object({
            boolean: z.boolean().optional()
        }).and(zModelWithEnum).and(zModelWithArray).and(zModelWithDictionary),
        z.null()
    ]).optional()
});

/**
 * This is a model with one property with a 'any of' relationship
 */
export const zCompositionWithAnyOfAndNullable = z.object({
    propA: z.union([
        z.object({
            boolean: z.boolean().optional()
        }),
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary,
        z.null()
    ]).optional()
});

/**
 * This is a base model with two simple optional properties
 */
export const zCompositionBaseModel = z.object({
    firstName: z.string().optional(),
    lastname: z.string().optional()
});

/**
 * This is a model that extends the base model
 */
export const zCompositionExtendedModel = zCompositionBaseModel.and(z.object({
    age: z.number(),
    firstName: z.string(),
    lastname: z.string()
}));

/**
 * This is a model with one nested property
 */
export const zModelWithNestedProperties = z.object({
    first: z.union([
        z.object({
            second: z.union([
                z.object({
                    third: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly()
                }).readonly(),
                z.null()
            ]).readonly()
        }).readonly(),
        z.null()
    ]).readonly()
});

/**
 * This is a model with duplicated properties
 */
export const zModelWithDuplicateProperties = z.object({
    prop: zModelWithString.optional()
});

/**
 * This is a model with ordered properties
 */
export const zModelWithOrderedProperties = z.object({
    zebra: z.string().optional(),
    apple: z.string().optional(),
    hawaii: z.string().optional()
});

/**
 * This is a model with duplicated imports
 */
export const zModelWithDuplicateImports = z.object({
    propA: zModelWithString.optional(),
    propB: zModelWithString.optional(),
    propC: zModelWithString.optional()
});

/**
 * This is a model that extends another model
 */
export const zModelThatExtends = zModelWithString.and(z.object({
    propExtendsA: z.string().optional(),
    propExtendsB: zModelWithString.optional()
}));

/**
 * This is a model that extends another model
 */
export const zModelThatExtendsExtends = zModelWithString.and(zModelThatExtends).and(z.object({
    propExtendsC: z.string().optional(),
    propExtendsD: zModelWithString.optional()
}));

/**
 * This is a model that contains a some patterns
 */
export const zModelWithPattern = z.object({
    key: z.string().max(64).regex(/^[a-zA-Z0-9_]*$/),
    name: z.string().max(255),
    enabled: z.boolean().readonly().optional(),
    modified: z.string().datetime().readonly().optional(),
    id: z.string().regex(/^\d{2}-\d{3}-\d{4}$/).optional(),
    text: z.string().regex(/^\w+$/).optional(),
    patternWithSingleQuotes: z.string().regex(/^[a-zA-Z0-9']*$/).optional(),
    patternWithNewline: z.string().regex(/aaa\nbbb/).optional(),
    patternWithBacktick: z.string().regex(/aaa`bbb/).optional()
});

export const zFile = z.object({
    id: z.string().min(1).readonly().optional(),
    updated_at: z.string().datetime().readonly().optional(),
    created_at: z.string().datetime().readonly().optional(),
    mime: z.string().min(1).max(24),
    file: z.string().url().readonly().optional()
});

export const zDefault = z.object({
    name: z.string().optional()
});

export const zPageable = z.object({
    page: z.number().int().gte(0).optional().default(0),
    size: z.number().int().gte(1).optional(),
    sort: z.array(z.string()).optional()
});

/**
 * This is a free-form object without additionalProperties.
 */
export const zFreeFormObjectWithoutAdditionalProperties = z.object({});

/**
 * This is a free-form object with additionalProperties: true.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqTrue = z.object({});

/**
 * This is a free-form object with additionalProperties: {}.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqEmptyObject = z.object({});

export const zModelWithConst = z.object({
    String: z.enum([
        'String'
    ]).optional(),
    number: z.unknown().optional(),
    null: z.unknown().optional(),
    withType: z.enum([
        'Some string'
    ]).optional()
});

/**
 * This is a model with one property and additionalProperties: true
 */
export const zModelWithAdditionalPropertiesEqTrue = z.object({
    prop: z.string().optional()
});

export const zNestedAnyOfArraysNullable = z.object({
    nullableArray: z.union([
        z.array(z.unknown()),
        z.null()
    ]).optional()
});

/**
 * This is a reusable parameter
 */
export const zSimpleParameter = z.unknown();

export const zCompositionWithOneOfAndProperties = z.intersection(z.union([
    z.object({
        foo: zSimpleParameter
    }),
    z.object({
        bar: zNonAsciiStringæøåÆøÅöôêÊ字符串
    })
]), z.object({
    baz: z.union([
        z.number().int().gte(0),
        z.null()
    ]),
    qux: z.number().int().gte(0)
}));

/**
 * An object that can be null
 */
export const zNullableObject = z.union([
    z.object({
        foo: z.string().optional()
    }),
    z.null()
]).default(null);

/**
 * Some % character
 */
export const zCharactersInDescription = z.string();

export const zModelWithNullableObject = z.object({
    data: zNullableObject.optional()
});

export const zModelWithOneOfEnum = z.union([
    z.object({
        foo: z.enum([
            'Bar'
        ])
    }),
    z.object({
        foo: z.enum([
            'Baz'
        ])
    }),
    z.object({
        foo: z.enum([
            'Qux'
        ])
    }),
    z.object({
        content: z.string().datetime(),
        foo: z.enum([
            'Quux'
        ])
    }),
    z.object({
        content: z.unknown(),
        foo: z.enum([
            'Corge'
        ])
    })
]);

export const zModelWithNestedArrayEnumsDataFoo = z.enum([
    'foo',
    'bar'
]);

export const zModelWithNestedArrayEnumsDataBar = z.enum([
    'baz',
    'qux'
]);

export const zModelWithNestedArrayEnumsData = z.object({
    foo: z.array(zModelWithNestedArrayEnumsDataFoo).optional(),
    bar: z.array(zModelWithNestedArrayEnumsDataBar).optional()
});

export const zModelWithNestedArrayEnums = z.object({
    array_strings: z.array(z.string()).optional(),
    data: zModelWithNestedArrayEnumsData.optional()
});

export const zModelWithNestedCompositionEnums = z.object({
    foo: zModelWithNestedArrayEnumsDataFoo.optional()
});

export const zModelWithConstantSizeArray = z.unknown();

export const zModelWithAnyOfConstantSizeArray = z.unknown();

export const zModelWithPrefixItemsConstantSizeArray = z.array(z.unknown());

export const zModelWithAnyOfConstantSizeArrayNullable = z.unknown();

export const zModelWithAnyOfConstantSizeArrayWithNSizeAndOptions = z.unknown();

export const zModelWithAnyOfConstantSizeArrayAndIntersect = z.unknown();

export const zModelWithNumericEnumUnion = z.object({
    value: z.unknown().optional()
});

/**
 * Some description with `back ticks`
 */
export const zModelWithBackticksInDescription = z.object({
    template: z.string().optional()
});

export const zModelWithOneOfAndProperties = z.intersection(z.union([
    zSimpleParameter,
    zNonAsciiStringæøåÆøÅöôêÊ字符串
]), z.object({
    baz: z.union([
        z.number().int().gte(0),
        z.null()
    ]),
    qux: z.number().int().gte(0)
}));

/**
 * Model used to test deduplication strategy (unused)
 */
export const zParameterSimpleParameterUnused = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponse = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponse2 = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooData = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooData2 = z.string();

/**
 * Model with restricted keyword name
 */
export const zImport = z.string();

export const zSchemaWithFormRestrictedKeys = z.object({
    description: z.string().optional(),
    'x-enum-descriptions': z.string().optional(),
    'x-enum-varnames': z.string().optional(),
    'x-enumNames': z.string().optional(),
    title: z.string().optional(),
    object: z.object({
        description: z.string().optional(),
        'x-enum-descriptions': z.string().optional(),
        'x-enum-varnames': z.string().optional(),
        'x-enumNames': z.string().optional(),
        title: z.string().optional()
    }).optional(),
    array: z.array(z.object({
        description: z.string().optional(),
        'x-enum-descriptions': z.string().optional(),
        'x-enum-varnames': z.string().optional(),
        'x-enumNames': z.string().optional(),
        title: z.string().optional()
    })).optional()
});

/**
 * This schema was giving PascalCase transformations a hard time
 */
export const zIoK8sApimachineryPkgApisMetaV1Preconditions = z.object({
    resourceVersion: z.string().optional(),
    uid: z.string().optional()
});

/**
 * This schema was giving PascalCase transformations a hard time
 */
export const zIoK8sApimachineryPkgApisMetaV1DeleteOptions = z.object({
    preconditions: zIoK8sApimachineryPkgApisMetaV1Preconditions.optional()
});

export const zAdditionalPropertiesUnknownIssue = z.object({});

export const zAdditionalPropertiesUnknownIssue2 = z.object({});

export const zAdditionalPropertiesUnknownIssue3 = z.intersection(z.string(), z.object({
    entries: z.object({})
}));

export const zAdditionalPropertiesIntegerIssue = z.object({
    value: z.number().int()
});

export const zGenericSchemaDuplicateIssue1SystemBoolean = z.object({
    item: z.boolean().optional(),
    error: z.union([
        z.string(),
        z.null()
    ]).optional(),
    hasError: z.boolean().readonly().optional(),
    data: z.object({}).optional()
});

export const zGenericSchemaDuplicateIssue1SystemString = z.object({
    item: z.union([
        z.string(),
        z.null()
    ]).optional(),
    error: z.union([
        z.string(),
        z.null()
    ]).optional(),
    hasError: z.boolean().readonly().optional()
});

export const zOneOfAllOfIssue = z.union([
    z.intersection(z.union([
        zConstValue,
        zGenericSchemaDuplicateIssue1SystemBoolean
    ]), z3eNum1Период),
    zGenericSchemaDuplicateIssue1SystemString
]);

/**
 * Parameter with illegal characters
 */
export const zXFooBar = zModelWithString;

export const zSimpleRequestBody = zModelWithString;

export const zSimpleFormData = zModelWithString;

export const zImportData = z.union([
    zModelWithReadOnlyAndWriteOnly,
    zModelWithArrayReadOnlyAndWriteOnly
]);

export const zImportResponse = z.union([
    zModelFromZendesk,
    zModelWithReadOnlyAndWriteOnly
]);

/**
 * Success
 */
export const zApiVVersionODataControllerCountResponse = zModelFromZendesk;

/**
 * foo in method
 */
export const zGetApiVbyApiVersionSimpleOperationParameterFooParam = z.string();

/**
 * Response is a simple number
 */
export const zGetApiVbyApiVersionSimpleOperationResponse = z.number();

/**
 * foo in method
 */
export const zDeleteFooParameterFooParam = z.string();

/**
 * bar in method
 */
export const zDeleteFooParameterBarParam = z.string();

/**
 * Parameter with illegal characters
 */
export const zDeleteFooParameterXFooBar = zModelWithString;

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCallWithDescriptionsParameterParameterWithBreaks = z.string();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const zCallWithDescriptionsParameterParameterWithBackticks = z.string();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const zCallWithDescriptionsParameterParameterWithSlashes = z.string();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const zCallWithDescriptionsParameterParameterWithExpressionPlaceholders = z.string();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const zCallWithDescriptionsParameterParameterWithQuotes = z.string();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const zCallWithDescriptionsParameterParameterWithReservedCharacters = z.string();

/**
 * This parameter is deprecated
 * @deprecated
 */
export const zDeprecatedCallParameterParameter = z.union([
    zDeprecatedModel,
    z.null()
]);

/**
 * This is the parameter that goes into the body
 */
export const zCallWithParametersData = z.union([
    z.object({}),
    z.null()
]);

/**
 * This is the parameter that goes into the cookie
 */
export const zCallWithParametersParameterParameterCookie = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter that goes into the header
 */
export const zCallWithParametersParameterParameterHeader = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter that goes into the path
 */
export const zCallWithParametersParameterParameterPath = z.union([
    z.string(),
    z.null()
]);

/**
 * api-version should be required in standalone clients
 */
export const zCallWithParametersParameterApiVersion = z.union([
    z.string(),
    z.null()
]);

export const zCallWithParametersParameterFooRefEnum = zModelWithNestedArrayEnumsDataFoo;

export const zCallWithParametersParameterFooAllOfEnum = zModelWithNestedArrayEnumsDataFoo;

/**
 * This is the parameter that goes into the query params
 */
export const zCallWithParametersParameterCursor = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter that goes into the body
 */
export const zCallWithWeirdParameterNamesData = z.union([
    zModelWithString,
    z.null()
]);

/**
 * This is the parameter that goes into the cookie
 */
export const zCallWithWeirdParameterNamesParameterParameterCookie = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter that goes into the request header
 */
export const zCallWithWeirdParameterNamesParameterParameterHeader = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter that goes into the path
 */
export const zCallWithWeirdParameterNamesParameterParameterPath1 = z.string();

/**
 * This is the parameter that goes into the path
 */
export const zCallWithWeirdParameterNamesParameterParameterPath2 = z.string();

/**
 * This is the parameter that goes into the path
 */
export const zCallWithWeirdParameterNamesParameterParameterPath3 = z.string();

/**
 * api-version should be required in standalone clients
 */
export const zCallWithWeirdParameterNamesParameterApiVersion = z.union([
    z.string(),
    z.null()
]);

/**
 * This is the parameter with a reserved keyword
 */
export const zCallWithWeirdParameterNamesParameterDefault = z.string();

/**
 * This is the parameter that goes into the request query params
 */
export const zCallWithWeirdParameterNamesParameterParameterQuery = z.union([
    z.string(),
    z.null()
]);

/**
 * This is a required parameter
 */
export const zGetCallWithOptionalParamData = zModelWithOneOfEnum;

/**
 * This is an optional parameter
 */
export const zGetCallWithOptionalParamParameterPage = z.number();

/**
 * This is an optional parameter
 */
export const zPostCallWithOptionalParamData = z.object({
    offset: z.union([
        z.number(),
        z.null()
    ]).optional()
});

/**
 * This is a required parameter
 */
export const zPostCallWithOptionalParamParameterParameter = zPageable;

export const zPostCallWithOptionalParamResponse = z.union([
    z.number(),
    z.void()
]);

/**
 * A reusable request body
 */
export const zPostApiVbyApiVersionRequestBodyData = zSimpleRequestBody;

/**
 * This is a reusable parameter
 */
export const zPostApiVbyApiVersionRequestBodyParameterParameter = z.string();

/**
 * A reusable request body
 */
export const zPostApiVbyApiVersionFormDataData = zSimpleFormData;

/**
 * This is a reusable parameter
 */
export const zPostApiVbyApiVersionFormDataParameterParameter = z.string();

/**
 * This is a simple string with default value
 */
export const zCallWithDefaultParametersParameterParameterString = z.union([
    z.string().default('Hello World!'),
    z.null()
]).default('Hello World!');

/**
 * This is a simple number with default value
 */
export const zCallWithDefaultParametersParameterParameterNumber = z.union([
    z.number().default(123),
    z.null()
]).default(123);

/**
 * This is a simple boolean with default value
 */
export const zCallWithDefaultParametersParameterParameterBoolean = z.union([
    z.boolean().default(true),
    z.null()
]).default(true);

/**
 * This is a simple enum with default value
 */
export const zCallWithDefaultParametersParameterParameterEnum = z.enum([
    'Success',
    'Warning',
    'Error'
]);

/**
 * This is a simple model with default value
 */
export const zCallWithDefaultParametersParameterParameterModel = z.union([
    zModelWithString,
    z.null()
]);

/**
 * This is a simple string that is optional with default value
 */
export const zCallWithDefaultOptionalParametersParameterParameterString = z.string().default('Hello World!');

/**
 * This is a simple number that is optional with default value
 */
export const zCallWithDefaultOptionalParametersParameterParameterNumber = z.number().default(123);

/**
 * This is a simple boolean that is optional with default value
 */
export const zCallWithDefaultOptionalParametersParameterParameterBoolean = z.boolean().default(true);

/**
 * This is a simple enum that is optional with default value
 */
export const zCallWithDefaultOptionalParametersParameterParameterEnum = z.enum([
    'Success',
    'Warning',
    'Error'
]);

/**
 * This is a simple model that is optional with default value
 */
export const zCallWithDefaultOptionalParametersParameterParameterModel = zModelWithString;

/**
 * This is a optional string with default
 */
export const zCallToTestOrderOfParamsParameterParameterOptionalStringWithDefault = z.string().default('Hello World!');

/**
 * This is a optional string with empty default
 */
export const zCallToTestOrderOfParamsParameterParameterOptionalStringWithEmptyDefault = z.string().default('');

/**
 * This is a optional string with no default
 */
export const zCallToTestOrderOfParamsParameterParameterOptionalStringWithNoDefault = z.string();

/**
 * This is a string with default
 */
export const zCallToTestOrderOfParamsParameterParameterStringWithDefault = z.string().default('Hello World!');

/**
 * This is a string with empty default
 */
export const zCallToTestOrderOfParamsParameterParameterStringWithEmptyDefault = z.string().default('');

/**
 * This is a string with no default
 */
export const zCallToTestOrderOfParamsParameterParameterStringWithNoDefault = z.string();

/**
 * This is a string that can be null with no default
 */
export const zCallToTestOrderOfParamsParameterParameterStringNullableWithNoDefault = z.union([
    z.string(),
    z.null()
]);

/**
 * This is a string that can be null with default
 */
export const zCallToTestOrderOfParamsParameterParameterStringNullableWithDefault = z.union([
    z.string(),
    z.null()
]).default(null);

/**
 * Success
 */
export const zCallWithNoContentResponseResponse = z.void();

export const zCallWithResponseAndNoContentResponseResponse = z.union([
    z.number(),
    z.void()
]);

export const zDummyAResponse = z400;

/**
 * Success
 */
export const zDummyBResponse = z.void();

export const zCallWithResponseResponse = zImport;

export const zCallWithDuplicateResponsesResponse = z.union([
    zModelWithBoolean.and(zModelWithInteger),
    zModelWithString
]);

export const zCallWithResponsesResponse = z.union([
    z.object({
        '@namespace.string': z.string().readonly().optional(),
        '@namespace.integer': z.number().int().readonly().optional(),
        value: z.array(zModelWithString).readonly().optional()
    }),
    zModelThatExtends,
    zModelThatExtendsExtends
]);

/**
 * This is an array parameter that is sent as csv format (comma-separated values)
 */
export const zCollectionFormatParameterParameterArrayCsv = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is an array parameter that is sent as ssv format (space-separated values)
 */
export const zCollectionFormatParameterParameterArraySsv = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is an array parameter that is sent as tsv format (tab-separated values)
 */
export const zCollectionFormatParameterParameterArrayTsv = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is an array parameter that is sent as pipes format (pipe-separated values)
 */
export const zCollectionFormatParameterParameterArrayPipes = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is an array parameter that is sent as multi format (multiple parameter instances)
 */
export const zCollectionFormatParameterParameterArrayMulti = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is a number parameter
 */
export const zTypesParameterId = z.number().int();

/**
 * This is a number parameter
 */
export const zTypesParameterParameterNumber = z.number().default(123);

/**
 * This is a string parameter
 */
export const zTypesParameterParameterString = z.union([
    z.string().default('default'),
    z.null()
]).default('default');

/**
 * This is a boolean parameter
 */
export const zTypesParameterParameterBoolean = z.union([
    z.boolean().default(true),
    z.null()
]).default(true);

/**
 * This is an object parameter
 */
export const zTypesParameterParameterObject = z.union([
    z.object({}),
    z.null()
]).default(null);

/**
 * This is an array parameter
 */
export const zTypesParameterParameterArray = z.union([
    z.array(z.string()),
    z.null()
]);

/**
 * This is a dictionary parameter
 */
export const zTypesParameterParameterDictionary = z.union([
    z.object({}),
    z.null()
]);

/**
 * This is an enum parameter
 */
export const zTypesParameterParameterEnum = z.enum([
    'Success',
    'Warning',
    'Error'
]);

export const zTypesResponse = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.object({})
]);

export const zUploadFileData = z.string();

/**
 * api-version should be required in standalone clients
 */
export const zUploadFileParameterApiVersion = z.union([
    z.string(),
    z.null()
]);

export const zUploadFileResponse = z.boolean();

export const zFileResponseParameterId = z.string();

/**
 * api-version should be required in standalone clients
 */
export const zFileResponseParameterApiVersion = z.string();

/**
 * Success
 */
export const zFileResponseResponse = z.string();

/**
 * Parameter containing object
 */
export const zComplexTypesParameterParameterObject = z.object({
    first: z.object({
        second: z.object({
            third: z.string().optional()
        }).optional()
    }).optional()
});

/**
 * Parameter containing reference
 */
export const zComplexTypesParameterParameterReference = zModelWithString;

/**
 * Successful response
 */
export const zComplexTypesResponse = z.array(zModelWithString);

/**
 * OK
 */
export const zMultipartResponseResponse = z.object({
    file: z.string().optional(),
    metadata: z.object({
        foo: z.string().optional(),
        bar: z.string().optional()
    }).optional()
});

export const zMultipartRequestData = z.object({
    content: z.string().optional(),
    data: z.union([
        zModelWithString,
        z.null()
    ]).optional()
});

export const zComplexParamsData = z.object({
    key: z.union([
        z.string().max(64).regex(/^[a-zA-Z0-9_]*$/).readonly(),
        z.null()
    ]).readonly(),
    name: z.union([
        z.string().max(255),
        z.null()
    ]),
    enabled: z.boolean().optional().default(true),
    type: z.enum([
        'Monkey',
        'Horse',
        'Bird'
    ]),
    listOfModels: z.union([
        z.array(zModelWithString),
        z.null()
    ]).optional(),
    listOfStrings: z.union([
        z.array(z.string()),
        z.null()
    ]).optional(),
    parameters: z.union([
        zModelWithString,
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary
    ]),
    user: z.object({
        id: z.number().int().readonly().optional(),
        name: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly().optional()
    }).readonly().optional()
});

export const zComplexParamsParameterId = z.number().int();

/**
 * api-version should be required in standalone clients
 */
export const zComplexParamsParameterApiVersion = z.string();

/**
 * Success
 */
export const zComplexParamsResponse = zModelWithString;

/**
 * Status code to return
 */
export const zTestErrorCodeParameterStatus = z.number().int();

/**
 * Dummy input param
 */
export const zNonAsciiæøåÆøÅöôêÊ字符串ParameterNonAsciiParamæøåÆøÅöôêÊ = z.number().int();

/**
 * Successful response
 */
export const zNonAsciiæøåÆøÅöôêÊ字符串Response = z.array(zNonAsciiStringæøåÆøÅöôêÊ字符串);

export const zPutWithFormUrlEncodedData = zArrayWithStrings;