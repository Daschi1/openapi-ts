import fs from 'node:fs';
import path from 'node:path';

import ts from 'typescript';

import { compiler } from '../compiler';
import { type ImportExportItemObject, tsNodeToString } from '../compiler/utils';
import type { IR } from '../ir/types';
import { ensureValidIdentifier } from '../openApi/shared/utils/identifier';
import type { StringCase } from '../types/config';
import { stringCase } from '../utils/stringCase';
import { ensureDirSync } from './utils';

export interface Identifier {
  /**
   * Did this function add a new property to the file's `identifiers` map?
   */
  created: boolean;
  /**
   * The resolved identifier name. False means the identifier has been blacklisted.
   */
  name: string | false;
}

type NamespaceEntry = Pick<Identifier, 'name'> & {
  /**
   * Ref to the type in OpenAPI specification.
   */
  $ref: string;
};

export type Identifiers = Record<
  string,
  {
    /**
     * TypeScript enum only namespace.
     *
     * @example
     * ```ts
     * export enum Foo = {
     *   FOO = 'foo'
     * }
     * ```
     */
    enum?: Record<string, NamespaceEntry>;
    /**
     * Type namespace. Types, interfaces, and type aliases exist here.
     *
     * @example
     * ```ts
     * export type Foo = string;
     * ```
     */
    type?: Record<string, NamespaceEntry>;
    /**
     * Value namespace. Variables, functions, classes, and constants exist here.
     *
     * @example
     * ```js
     * export const foo = '';
     * ```
     */
    value?: Record<string, NamespaceEntry>;
  }
>;

type Namespace = keyof Identifiers[keyof Identifiers];

export type FileImportResult = Pick<ImportExportItemObject, 'asType' | 'name'>;

export class TypeScriptFile {
  /**
   * Should the exports from this file be re-exported in the index barrel file?
   */
  private _exportFromIndex: boolean;
  private _headers: Array<string> = [];
  private _id: string;
  private _identifierCase: StringCase | undefined;
  private _imports = new Map<string, Map<string, ImportExportItemObject>>();
  private _items: Array<ts.Node | string> = [];
  private _name: string;
  private _path: string;

  public identifiers: Identifiers = {};

  /**
   * Path relative to the client output root.
   */
  // TODO: parser - add relative path property for quick access, currently
  // everything is resolved into an absolute path with cwd
  // public relativePath: string;

  public constructor({
    dir,
    exportFromIndex = false,
    header = true,
    id,
    identifierCase,
    name,
  }: {
    dir: string;
    /**
     * Should the exports from this file be re-exported in the index barrel file?
     */
    exportFromIndex?: boolean;
    header?: boolean;
    /**
     * Unique file ID. Used to generate correct relative paths to the file.
     * This should be refactored later as it's basically the file name unless
     * nested inside another folder.
     */
    id: string;
    identifierCase?: StringCase;
    name: string;
  }) {
    this._exportFromIndex = exportFromIndex;
    this._id = id;
    this._identifierCase = identifierCase;
    this._name = this._setName(name);
    this._path = path.resolve(dir, this._name);

    if (header) {
      this._headers.push(
        '// This file is auto-generated by @hey-api/openapi-ts',
      );
    }
  }

  public add(...nodes: Array<ts.Node | string>) {
    this._items = this._items.concat(nodes);
  }

  /**
   * Prevents a specific identifier from being created. This is useful for
   * transformers where we know a certain transformer won't be needed, and
   * we want to avoid attempting to create since we know it won't happen.
   */
  public blockIdentifier({
    $ref,
    namespace,
  }: Pick<EnsureUniqueIdentifierData, '$ref'> & {
    namespace: Namespace;
  }): Identifier {
    const { name, ref } = parseRef($ref);
    const refValue =
      this.identifiers[name.toLocaleLowerCase()]?.[namespace]?.[ref];
    if (!refValue) {
      throw new Error(
        `Identifier for $ref ${$ref} in namespace ${namespace} not found`,
      );
    }

    refValue.name = false;

    return {
      created: false,
      name: refValue.name,
    };
  }

  public get exportFromIndex(): boolean {
    return this._exportFromIndex;
  }

  public get id(): string {
    return this._id;
  }

  public identifier(
    args: Pick<
      EnsureUniqueIdentifierData,
      '$ref' | 'count' | 'create' | 'nameTransformer'
    > & {
      namespace: Namespace;
    },
  ): Identifier {
    return ensureUniqueIdentifier({
      case: this._identifierCase,
      identifiers: this.identifiers,
      ...args,
    });
  }

  /**
   * Adds an import to the provided module. Handles duplication, returns added
   * import. Returns the imported name. If we import an aliased export, `name`
   * will be equal to the specified `alias`.
   */
  public import({
    module,
    ...importedItem
  }: ImportExportItemObject & {
    module: string;
  }): FileImportResult {
    let moduleMap = this._imports.get(module);

    if (!moduleMap) {
      moduleMap = new Map<string, ImportExportItemObject>();
      this._imports.set(module, moduleMap);
    }

    const match = moduleMap.get(importedItem.name);
    if (match) {
      return {
        ...match,
        name: match.alias || match.name,
      };
    }

    moduleMap.set(importedItem.name, importedItem);
    return {
      ...importedItem,
      name: importedItem.alias || importedItem.name,
    };
  }

  public isEmpty() {
    return !this._items.length;
  }

  public nameWithoutExtension() {
    const { name } = splitNameAndExtension(this._name);
    return name;
  }

  public relativePathToFile({
    context,
    id,
  }: {
    context: IR.Context;
    id: string;
  }): string {
    let filePath = '';

    // relative file path
    if (id.startsWith('.')) {
      let configFileParts: Array<string> = [];
      // if providing a custom configuration file, relative paths must resolve
      // relative to the configuration file.
      if (context.config.configFile) {
        const cfgParts = context.config.configFile.split('/');
        configFileParts = cfgParts.slice(0, cfgParts.length - 1);
      }
      filePath = path.resolve(process.cwd(), ...configFileParts, id);
    } else {
      const file = context.file({ id });
      if (!file) {
        throw new Error(`File with id ${id} does not exist`);
      }
      filePath = file._path;
    }

    const thisPathParts = this._path.split(path.sep);
    const filePathParts = filePath.split(path.sep);

    let index = -1;
    let relativePath = '';
    for (const part of thisPathParts) {
      index += 1;
      if (filePathParts[index] !== part) {
        const pathArray = Array.from({
          length: thisPathParts.length - index,
        }).fill('');
        const relativePathToFile = filePathParts.slice(index);
        const relativeFolder = relativePathToFile.slice(
          0,
          relativePathToFile.length - 1,
        );
        if (relativeFolder.length) {
          relativeFolder.push('');
        }
        relativePath =
          (pathArray.join('../') || './') + relativeFolder.join('/');
        break;
      }
    }

    const fileName = filePathParts[filePathParts.length - 1]!;
    // TODO: parser - cache responses
    return `${relativePath}${splitNameAndExtension(fileName).name}`;
  }

  public remove(options?: Parameters<typeof fs.rmSync>[1]) {
    fs.rmSync(this._path, options);
  }

  /**
   * Removes last node form the stack. Works as undo.
   */
  public removeNode() {
    this._items = this._items.slice(0, this._items.length - 1);
  }

  private _setName(fileName: string) {
    if (fileName.includes('index')) {
      return fileName;
    }

    const { extension, name } = splitNameAndExtension(fileName);
    return [name, 'gen', extension].filter(Boolean).join('.');
  }

  private _toString(separator: string, tsConfig: ts.ParsedCommandLine | null) {
    let output: Array<string> = [];
    if (this._headers.length) {
      output.push(this._headers.join('\n'));
    }

    const shouldAppendJs =
      tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext;

    const importsStringArray: Array<string> = [];

    for (const [_module, moduleMap] of this._imports.entries()) {
      const imports = Array.from(moduleMap.values());

      let resolvedModule = _module;
      if (
        shouldAppendJs &&
        (resolvedModule.startsWith('./') || resolvedModule.startsWith('../'))
      ) {
        if (resolvedModule === './client') {
          resolvedModule = './client/index.js';
        } else {
          resolvedModule = `${resolvedModule}.js`;
        }
      }

      const node = compiler.namedImportDeclarations({
        imports,
        module: resolvedModule,
      });
      importsStringArray.push(tsNodeToString({ node }));
    }
    if (importsStringArray.length) {
      output.push(importsStringArray.join('\n'));
    }
    output = output.concat(
      this._items.map((node) =>
        typeof node === 'string'
          ? node
          : tsNodeToString({ node, unescape: true }),
      ),
    );
    return output.join(separator);
  }

  public write(separator = '\n', tsConfig: ts.ParsedCommandLine | null = null) {
    if (this.isEmpty()) {
      this.remove({ force: true });
      return;
    }

    let dir = this._path;
    if (typeof this._path === 'string') {
      const parts = this._path.split(path.sep);
      dir = parts.slice(0, parts.length - 1).join(path.sep);
    }
    ensureDirSync(dir);
    fs.writeFileSync(this._path, this._toString(separator, tsConfig));
  }
}

const parseRef = (
  $ref: string,
): {
  /**
   * Extracted name from `$ref`, equal to the last part or property name.
   */
  name: string;
  /**
   * List of properties extracted from `$ref`, if any.
   */
  properties: ReadonlyArray<string>;
  /**
   * `$ref` without properties if they're included in `$ref`, otherwise
   * `ref` is equal to `$ref`.
   */
  ref: string;
} => {
  let ref = $ref;
  const properties: string[] = [];

  const parts = ref.split('/');
  let name = parts[parts.length - 1] || '';

  let propIndex = parts.indexOf('properties');

  if (propIndex !== -1) {
    ref = parts.slice(0, propIndex).join('/');
    name = parts[propIndex - 1] || '';

    while (propIndex + 1 < parts.length) {
      const prop = parts[propIndex + 1];
      if (!prop) {
        throw new Error(`Invalid $ref: ${$ref}`);
      }
      properties.push(prop);
      propIndex += 2;
    }
  }

  return {
    name,
    properties,
    ref,
  };
};

interface EnsureUniqueIdentifierData {
  $ref: string;
  case: StringCase | undefined;
  count?: number;
  create?: boolean;
  identifiers: Identifiers;
  /**
   * Transforms name obtained from `$ref` before it's passed to `stringCase()`.
   */
  nameTransformer?: (name: string) => string;
  namespace: Namespace;
}

const ensureUniqueIdentifier = ({
  $ref,
  case: identifierCase,
  count = 1,
  create = false,
  identifiers,
  nameTransformer,
  namespace,
}: EnsureUniqueIdentifierData): Identifier => {
  const { name, properties, ref } = parseRef($ref);

  if (!name) {
    return {
      created: false,
      name: '',
    };
  }

  let nameWithCasing = stringCase({
    case: identifierCase,
    value: name,
  });
  if (count > 1) {
    nameWithCasing = `${nameWithCasing}${count}`;
  }
  const lowercaseName = nameWithCasing.toLocaleLowerCase();
  if (!identifiers[lowercaseName]) {
    identifiers[lowercaseName] = {};
  }
  const identifier = identifiers[lowercaseName];

  // Enum declarations can only merge with namespace or other enum
  // declarations, so we need to ensure we don't mix them up.
  if (
    (namespace === 'enum' && (identifier.type || identifier.value)) ||
    (namespace !== 'enum' && identifier.enum)
  ) {
    return ensureUniqueIdentifier({
      $ref: ref,
      case: identifierCase,
      count: count + 1,
      create,
      identifiers,
      nameTransformer,
      namespace,
    });
  }

  if (!identifier[namespace]) {
    identifier[namespace] = {};
  }
  const id = identifier[namespace];

  const refValue = id[ref];
  if (refValue) {
    let name = refValue.name;
    if (properties.length) {
      name += properties.map((property) => `['${property}']`).join('');
    }
    return {
      created: false,
      name: name as string,
    };
  }

  let nameWithCasingAndTransformer = stringCase({
    case: identifierCase,
    value: nameTransformer?.(name) ?? name,
  });
  if (count > 1) {
    nameWithCasingAndTransformer = `${nameWithCasingAndTransformer}${count}`;
  }

  let nameValue = id[nameWithCasingAndTransformer];
  if (nameValue) {
    if (nameValue.$ref === ref) {
      return {
        created: false,
        name: nameValue.name,
      };
    }

    return ensureUniqueIdentifier({
      $ref: ref,
      case: identifierCase,
      count: count + 1,
      create,
      identifiers,
      nameTransformer,
      namespace,
    });
  }

  if (!create) {
    delete identifier[namespace];
    return {
      created: false,
      name: '',
    };
  }

  nameValue = {
    $ref: ref,
    name: ensureValidIdentifier(nameWithCasingAndTransformer),
  };
  id[nameWithCasingAndTransformer] = nameValue;
  id[nameValue.$ref] = nameValue;

  return {
    created: true,
    name: nameValue.name,
  };
};

const splitNameAndExtension = (fileName: string) => {
  const match = fileName.match(/\.[0-9a-z]+$/i);
  const extension = match ? match[0].slice(1) : '';
  const name = fileName.slice(
    0,
    fileName.length - (extension ? extension.length + 1 : 0),
  );
  return { extension, name };
};

export const _test = {
  ensureUniqueIdentifier,
  parseRef,
  splitNameAndExtension,
};
